#!/bin/bash
# shellcheck disable=SC2207,SC2128,SC2001,SC2046,SC2029,SC2059,SC2155

set -efu -o pipefail
export LANG=C LC_ALL=C

  BRIGHT=$'\e[1m'
     RED=$'\e[1;31m'
   GREEN=$'\e[1;32m'
  YELLOW=$'\e[1;33m'
    BLUE=$'\e[1;34m'
 MAGENTA=$'\e[1;35m'
    CYAN=$'\e[1;36m'
   WHITE=$'\e[1;37m'
    NORM=$'\e[m'
export BRIGHT RED GREEN YELLOW BLUE MAGENTA CYAN WHITE NORM

fatal() {
	printf >&2 "${RED}Error: %s${NORM}\n" "$*"
	exit 1
}

taillogs=
waitstate=
state=
select=

while [ $# -gt 0 ]; do
	opt=$1
	case "$opt" in
		--tail) export taillogs=y ;;
		--wait) waitstate=y ;;
		--state=*) state=${opt#*=} ;;
		-i) select=y ;;
		-*) fatal "Unknown option: $opt" ;;
		*) break ;;
	esac
	shift
done

toplevel=$(git rev-parse --show-toplevel 2>/dev/null ||:)
if [ -z "$toplevel" ]; then
	cd -P ~/.girar-build-repo
	echo "- cd $PWD"
	toplevel=$PWD
fi
cd "$toplevel"

TASKLIST=.git/.girar-build
if [ -n "$select" ]; then
	taskls=$(ssh -n "${1-girar}" task ls | fzf)
	taskls=${taskls%% *}
	task_id=${taskls#"#"}
	task_try=
elif [ $# -gt 0 ]; then
	task_id=$1
	task_try=${2-}
elif [ -s "$TASKLIST" ]; then
	PPIDID=$PPID:$(date -r "/proc/$PPID" +%s)
	task_id=$(awk "\$3 == \"$PPIDID\" {print\$1}" "$TASKLIST" | tail -1)
	if [ -n "$task_id" ]; then
		echo "- Last task in this shell $task_id"
	else
		task_id=$(tail -1 "$TASKLIST" | cut -f1)
		echo "- Last task in this repo $task_id"
	fi
	task_try=
fi
[ -z "${task_id-}" ] && fatal "Unknown task id"

declare -i sleepmin=5 sleepmax=60
declare -i sleepfor=$sleepmin
update_sleep_time() {
	if [ "${1-}" = '--reset' ]; then
		sleepfor=$sleepmin
	elif [[ sleepfor -lt sleepmax ]]; then
		local -i step=11
		# shellcheck disable=SC2034
		[[ sleepfor -gt 30 ]] || step=5
		sleepfor+=step
	fi
}

logtmp=$(mktemp) && trap 'rm -- $logtmp' 0
task_url="https://git.altlinux.org/tasks/$task_id"
echo "- $BRIGHT$task_url/$NORM"
events_log=
declare -i log_lines=0 task_iter=1
show_events_log() {
	local log=$1
	local url="$task_url/logs/$log"
	local cont=
	[ "$log" = "$events_log" ] && cont=-C-
	curl -sSLf "$url" $cont -o "$logtmp" 2>/dev/null || return 1
	if [ "$log" != "$events_log" ]; then
		echo "${BLUE}=== $log ===${NORM}"
		events_log=$log
		log_lines=1
	fi
	tail -n+"$log_lines" "$logtmp" \
		| sed -E \
		-e "s/(^\[\w+\])(.*)/$NORM\1$MAGENTA\2$NORM/" \
		-e "s/.*(ERROR|FAIL|FATAL).*/$RED&$NORM/" \
		-e "s/.*(TESTED|DONE).*/$GREEN&$NORM/" \
		-e "s/\b(OK|ALLOWED)\b/$GREEN&$NORM/" \

	local -i lines=log_lines
	log_lines=$(wc -l < "$logtmp")+1
	[[ log_lines -eq lines ]] || update_sleep_time --reset
}
iterate_over_logs() {
	local last_try=$(curl -sSLf "$task_url/task/try")
	# If user not specified 'try' argument, do not start from beginning.
	if [ -z "$task_try" ]; then
		task_try=$last_try
		task_iter=$(curl -sSLf "$task_url/task/iter")
	fi
	for ((t=task_try;t<=last_try;t++)); do
		for ((i=task_iter;;i++)); do
			show_events_log "events.$t.$i.log" || break
		done
	done
	task_try=$last_try
	wait_inactive_state
}

colorize_state() {
	local color=
	case "$1" in
		AWAITING|POSTPONED) color=$BLUE ;;
		DONE|EPERM|TESTED) color=$GREEN ;;
		FAIL*) color=$RED ;;
		*) color=$CYAN ;;
	esac
	echo "$color$1$NORM"
}
cstate=$(colorize_state "$state")

wait_inactive_state() {
	local oldstate=$state
	state=$(curl -sSLf "$task_url/task/state" | cat -v)
	cstate=$(colorize_state "$state")
	case "$state" in
		AWAITING|BUILDING|COMMITTING|FAILING|PENDING)
			if [ "$state" != "$oldstate" ] && [ -n "$oldstate" ]; then
				echo "- Task entered active state $cstate."
			fi
			return 0
			;;
		DONE|EPERM|FAILED|NEW|POSTPONED|SWEPT|TESTED)
			echo "- Task entered inactive state $cstate."
			return 1
			;;
		*)
			echo "- Task entered unknown state $cstate."
			return 0
			;;
	esac
}

if [ -n "$waitstate" ]; then
	while true; do
		wait_inactive_state
		gum spin --title="Waiting while $cstate..." sleep "$sleepfor"
		update_sleep_time
	done
else
	while true; do
		iterate_over_logs
		gum spin --title="Waiting on $events_log while $cstate..." sleep "$sleepfor"
		update_sleep_time
	done
fi
