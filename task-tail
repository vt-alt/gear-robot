#!/bin/bash
# shellcheck disable=SC2207,SC2128,SC2001,SC2046,SC2029,SC2059

set -efu -o pipefail
export LANG=C LC_ALL=C

   RED=$'\e[1;31m'
 GREEN=$'\e[1;32m'
  BLUE=$'\e[1;34m'
  NORM=$'\e[m'
export RED GREEN BLUE NORM

fatal() {
	printf >&2 "${RED}Error: %s${NORM}\n" "$*"
	exit 1
}

taillogs=
waitstate=
state=

while [ $# -gt 0 ]; do
	opt=$1
	case "$opt" in
		--tail) taillogs=y ;;
		--wait) waitstate=y ;;
		--state=*) state=${opt#*=} ;;
		-*) fatal "Unknown option: $opt" ;;
		*) break ;;
	esac
	shift
done

task_id=${1?need task id argument}
task_try=${2-}

declare -i sleepmin=11 sleepmax=600
declare -i sleepfor=$sleepmin
update_sleep_time() {
	if [ "$1" = reset ]; then
		sleepfor=$sleepmin
	elif [ "$sleepfor" -lt "$sleepmax" ]; then
		sleepfor+=$1
	fi
}

logtmp=$(mktemp) && trap "rm -- $logtmp" 0
task_url="https://git.altlinux.org/tasks/$task_id"
events_log=
declare -i log_lines=0 task_iter=1
show_events_log() {
	local log=$1
	local url="$task_url/logs/$log"
	curl -sSLf "$url" -o "$logtmp" 2>/dev/null || return 1
	if [ "$log" != "$events_log" ]; then
		echo "${BLUE}=== $log ===${NORM}"
		events_log=$log
		log_lines=1
	fi
	tail -n+"$log_lines" "$logtmp" \
		| sed -E \
		-e "s/.*(ERROR|FAIL|FATAL).*/$RED&$NORM/" \
		-e "s/.*(TESTED|DONE).*/$GREEN&$NORM/" \
		-e "s/\b(OK|ALLOWED)\b/$GREEN&$NORM/" \

	update_sleep_time reset
	sleepfor=$sleepmin
	log_lines=$(wc -l < "$logtmp")+1
}
iterate_over_logs() {
	local last_try=$(curl -sSLf "$task_url/task/try")
	# If user not specified 'try' argument, do not start from beginning.
	if [ -z "$task_try" ]; then
		task_try=$last_try
		task_iter=$(curl -sSLf "$task_url/task/iter")
	fi
	for ((t=$task_try;t<=$last_try;t++)); do
		for ((i=$task_iter;;i++)); do
			show_events_log "events.$t.$i.log" || break
		done
	done
	task_try=$last_try
	wait_inactive_state
}

wait_inactive_state() {
	update_sleep_time 1
	local oldstate=$state
	state=$(curl -sSLf "$task_url/task/state")
	case "$state" in
		AWAITING|BUILDING|COMMITTING|FAILING|PENDING)
			if [ "$state" != "$oldstate" ] && [ -n "$oldstate" ]; then
				echo "- Task entered new active state $state."
			fi
			return 0
			;;
		DONE|EPERM|FAILED|NEW|POSTPONED|SWEPT|TESTED)
			echo "- Task is in inactive state $state, exiting."
			return 1
			;;
		*)
			echo "- Task in unknown state $state."
			return 0
			;;
	esac
}

if [ -n "$waitstate" ]; then
	while true; do
		wait_inactive_state
		gum spin --title="Waiting while $state..." sleep "$sleepfor"
	done
else
	while true; do
		iterate_over_logs
		gum spin --title="Waiting on $events_log..." sleep "$sleepfor"
	done
fi
