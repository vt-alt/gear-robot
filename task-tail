#!/bin/bash
# shellcheck disable=SC2207,SC2128,SC2001,SC2046,SC2029,SC2059,SC2155

set -efu -o pipefail
export LANG=C LC_ALL=C

     RED=$'\e[1;31m'
   GREEN=$'\e[1;32m'
    BLUE=$'\e[1;34m'
 MAGENTA=$'\e[1;35m'
    NORM=$'\e[m'
export RED GREEN BLUE MAGENTA NORM

fatal() {
	printf >&2 "${RED}Error: %s${NORM}\n" "$*"
	exit 1
}

taillogs=
waitstate=
state=

while [ $# -gt 0 ]; do
	opt=$1
	case "$opt" in
		--tail) export taillogs=y ;;
		--wait) waitstate=y ;;
		--state=*) state=${opt#*=} ;;
		-*) fatal "Unknown option: $opt" ;;
		*) break ;;
	esac
	shift
done

task_id=${1?need task id argument}
task_try=${2-}

declare -i sleepmin=5 sleepmax=60
declare -i sleepfor=$sleepmin
update_sleep_time() {
	if [ "${1-}" = '--reset' ]; then
		sleepfor=$sleepmin
	elif [[ sleepfor -lt sleepmax ]]; then
		local -i step=11
		# shellcheck disable=SC2034
		[[ sleepfor -gt 30 ]] || step=5
		sleepfor+=step
	fi
}

logtmp=$(mktemp) && trap 'rm -- $logtmp' 0
task_url="https://git.altlinux.org/tasks/$task_id"
events_log=
declare -i log_lines=0 task_iter=1
show_events_log() {
	local log=$1
	local url="$task_url/logs/$log"
	curl -sSLf "$url" -o "$logtmp" 2>/dev/null || return 1
	if [ "$log" != "$events_log" ]; then
		echo "${BLUE}=== $log ===${NORM}"
		events_log=$log
		log_lines=1
	fi
	tail -n+"$log_lines" "$logtmp" \
		| sed -E \
		-e "s/(^\[\w+\])(.*)/$NORM\1$MAGENTA\2$NORM/" \
		-e "s/.*(ERROR|FAIL|FATAL).*/$RED&$NORM/" \
		-e "s/.*(TESTED|DONE).*/$GREEN&$NORM/" \
		-e "s/\b(OK|ALLOWED)\b/$GREEN&$NORM/" \

	local -i lines=log_lines
	log_lines=$(wc -l < "$logtmp")+1
	[[ log_lines -eq lines ]] || update_sleep_time --reset
}
iterate_over_logs() {
	local last_try=$(curl -sSLf "$task_url/task/try")
	# If user not specified 'try' argument, do not start from beginning.
	if [ -z "$task_try" ]; then
		task_try=$last_try
		task_iter=$(curl -sSLf "$task_url/task/iter")
	fi
	for ((t=task_try;t<=last_try;t++)); do
		for ((i=task_iter;;i++)); do
			show_events_log "events.$t.$i.log" || break
		done
	done
	task_try=$last_try
	wait_inactive_state
}

wait_inactive_state() {
	local oldstate=$state
	state=$(curl -sSLf "$task_url/task/state")
	case "$state" in
		AWAITING|BUILDING|COMMITTING|FAILING|PENDING)
			if [ "$state" != "$oldstate" ] && [ -n "$oldstate" ]; then
				echo "- Task entered active state $state."
			fi
			return 0
			;;
		DONE|EPERM|FAILED|NEW|POSTPONED|SWEPT|TESTED)
			echo "- Task entered inactive state $state."
			return 1
			;;
		*)
			echo "- Task entered unknown state $state."
			return 0
			;;
	esac
}

if [ -n "$waitstate" ]; then
	while true; do
		wait_inactive_state
		gum spin --title="Waiting while $state..." sleep "$sleepfor"
		update_sleep_time
	done
else
	while true; do
		iterate_over_logs
		gum spin --title="Waiting on $events_log while $state..." sleep "$sleepfor"
		update_sleep_time
	done
fi
