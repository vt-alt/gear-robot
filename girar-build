#!/bin/bash
# shellcheck disable=SC2207,SC2128,SC2001,SC2046,SC2029,SC2059

set -efu -o pipefail
export LANG=C LC_ALL=C

   RED=$'\e[1;31m'
 GREEN=$'\e[1;32m'
  BLUE=$'\e[1;34m'
  NORM=$'\e[m'
export RED GREEN BLUE NORM

V() {
        printf >&2 "${GREEN}+"
        printf >&2 ' %q' "$@"
        printf >&2 "${NORM}\n"
        "$@"
}

fatal() {
	printf >&2 "${RED}Error: %s${NORM}\n" "$*"
	exit 1
}

force=
commit=--test-only
norun=
dryrun=
failwhen=
hurry=
newtask=
e2k=
girar=
gitery=
branch=sisyphus
disapprove=
task_id=
skip_repo_check=
taillogs=
while [ $# -gt 0 ]; do
	opt=$1
	case "$opt" in
		-f | --force) force=-f ;;
		--tail) taillogs=--tail ;;
		--wait) taillogs=--wait ;;
		--commit) commit=--commit ;;
		-n | --no-run) norun=y ;;
		--dry | --dry-run) dryrun=--dry-run ;;
		--new | --new-task ) newtask=y ;;
		--fail-early) failwhen=--fail-early ;;
		--fail-late) failwhen=--fail-late ;;
		--hurry|--swift) hurry=--hurry ;;
		--unhurry) hurry=--unhurry ;;
		--task=*) task_id=${opt#*=} ;;
		--e2k ) e2k=y ;;
		--repo=*) branch=${opt#*=} ;;
		--dis* | --test ) disapprove=TEST ;;
		--tag=*) tag=${opt#*=} ;;
		--skip-repo-check) skip_repo_check=y ;;
		*) fatal "Unknown option: $opt" ;;
	esac
	shift
done
toplevel=$(git rev-parse --show-toplevel)
cd "$toplevel"

# Determine gitery remote
if [ -n "$e2k" ]; then
	girar='girar-e2k'
	gitery='gitery-e2k'
else
	girar='girar'
	gitery='gitery'
	if [ -e .git/refs/remotes/git.alt ]; then
		V git remote rename "git.alt" "$gitery"
	fi
	indexbase="http://ftp.altlinux.org/pub/distributions/archive/$branch/index/src"
fi
if ! git config "remote.$gitery.url" >& /dev/null; then
	topname=$(basename "$toplevel")
	V ssh -n "$gitery" init-db "$topname"
	V git remote add "$gitery" "$gitery:packages/${topname}.git"
fi

gear_describe() {
        # shellcheck disable=SC2046
        set -- $(gear --describe --disable-specsubst)
        export NAME=$1 VERSION=$2 RELEASE=$3
}
gear_describe

if [ -z "${tag-}" ]; then
	tag=( $(git tag --points-at @ '*-alt*') )
	if [ ${#tag[@]} -gt 1 ]; then
		fatal "Too many -alt tags: ${tag[*]}."
	elif [ ${#tag[@]} -ne 1 ]; then
		echo "${BLUE}Top level commit is not tagged with -alt tag!$NORM"
		havetag=$(git tag -l "$VERSION-$RELEASE")
		[ -n "$havetag" ] && [ -z "$force" ] && fatal "Run with -f to force new tag"
		gum confirm "Run gear-create-tag $force?"
		gear-create-tag $force
		unset havetag
		tag=( $(git tag --points-at @ "$VERSION-$RELEASE") )
	fi
	tag_id=$(git show-ref --tags "$tag" | cut -d' ' -f1)
	[ -n "$tag_id" ] || fatal "tag_id empty."
fi

# Remote repo name
url=$(git remote get-url "$gitery")
repo=$(basename "$url")
dir_repo=${url##*:}

# Check existence of the package.
unset lastbuild lastver lastgear lasttag
if [ -n "$indexbase" ] && [ -z "$skip_repo_check" ]; then
	indexurl="$indexbase/${NAME:0:1}/$NAME/d-t-s-evr.list"
	if ! dts_list=$(curl -sSfL "$indexurl"); then
		echo "Package $NAME not found in $branch."
	else
		if echo "$dts_list" | awk "\$4 == \"$tag\"" | grep .; then
			# Just informational and superseded by the following check.
			echo "The same version $tag is already committed to $branch"
		fi
		lastbuild=$(echo "$dts_list" | awk '$4 != "-"' | tail -1)
		lastver=$(echo "$lastbuild" | cut -f4)
		cmp=$(rpmevrcmp "$tag" "$lastver")
		if [ "$cmp" -eq -1 ]; then
			fatal "There is newer version $lastver > $tag already in $branch"
		elif [ "$cmp" -eq 0 ]; then
			fatal "Same version $lastver already latest in $branch"
		elif [ "$cmp" -eq 1 ]; then
			echo "This version $tag is newer than last ($lastver) in $branch"
		else
			fatal "Version comparison error $tag vs $lastver = $cmp"
		fi
		lastbuild=$(echo "$dts_list" | tail -1)
		lastgear=$(echo "$lastbuild" | cut -f5)
		if [ -n "$lastgear" ]; then
			lastgear=${lastgear#gear:}
			lasttag=$(git cat-file -p "$lastgear" | grep -m1 '^tag ')
			lasttag=${lasttag#tag }
		fi
	fi
fi

# Is this WiP build?
if [ -n "${lasttag-}" ]; then
	selector="$lasttag.."
else
	selector="--author=altlinux"
fi
# shellcheck disable=SC2086
if git log --format='%m %h %ad %s' --date=short --first-parent $selector \
	| grep --color=auto -iP '\b(wip|test)\b'; then
	echo "Seems to be work-in-progress build, disapproving"
	disapprove=WIP
fi
# shellcheck disable=SC2086
if git log --format='%s' --first-parent $selector | sort | uniq -c \
	| grep -v '^      1 '; then
	echo "Does have duplicate commit messages, disapproving"
	disapprove=WIP
fi
if [[ "$RELEASE" =~ test\|wip ]]; then
	echo "Seems to be work-in-progress release, disapproving"
	disapprove=WIP
fi

V git push "$gitery" "$tag" $force

# Determine target task number
if [ -n "$task_id" ]; then
	tasks_ls=$(ssh -n "$girar" task ls --brief)
	task_matched=$(echo "$tasks_ls" | grep "^#$task_id " || :)
	[ -n "$task_matched" ] || fatal "${RED}Requested task does not exist${NORM}"
	echo >&2 "- Using existing task $task_id"
elif [ -n "$newtask" ]; then
	unset task_matched
else
	# Use heuristic to search for appropriate task.
	tasks_ls=$(ssh -n "$girar" task ls)
	if [ -s ~/.task-lock ]; then
		tasks_ls=$(echo "$tasks_ls" | grep -v -w -f ~/.task-lock)
	fi
	task_matched=$(echo "$tasks_ls" | grep -m1 -w -F "$repo=$tag" || :)
	if [ -n "$task_matched" ]; then
		if [ "$(echo "$task_matched" | wc -l)" -ne 1 ]; then
			echo >&2 "${RED}Too much tasks with $repo=$tag found:${NORM}"
			echo >&2
			echo "$task_matched" | sed 's/^/   /' >&2
			echo >&2
			exit 1
		fi
		task_id=${task_matched%% *}
		task_id=${task_id#\#}
		echo >&2 "- Task to rebuild $repo=$tag found: $task_id"
	fi
fi
unset tasks_ls

wait_state() {
	local -i count=0
	while true; do
		task_state=$(curl -sSf "https://git.altlinux.org/tasks/$task_id/task/state")
		case "$task_state" in
			FAILED | NEW | TESTED | EPERM) return ;;
		esac
		if [[ $count -eq 0 ]]; then
			echo "Task $task_id is in unmodifiable state $task_state, waiting..."
		fi
		local elapsed
		printf -v elapsed "%d:%02d" $((count/60)) $((count%60))
		gum spin --title="[state=$task_state, elapsed $elapsed] Waiting..." sleep 60
		count+=1
	done
}

task_state=
declare -i sub_count=0
if [ -z "$task_id" ]; then
	# shellcheck disable=SC2086
	task_id=$(V ssh -n "$girar" task new $branch)
	echo >&2 "- Creating new task $task_id"
	task_show=
	task_try=1
else
	task_state=$(echo "$task_matched" | cut -d' ' -f2)
	wait_state
	task_show=$(ssh -n "$girar" task show --brief "$task_id")
	sub_count=$(echo "$task_show" | grep -E '^[[:space:]]*[[:digit:]]+:' -c)
	task_try=$(echo "$task_show" | head -1 | grep -oP '(?<=\btry=)\d+')
fi
unset task_matched
unset task_state

subtask=
nexttask=
if [ -n "$task_show" ]; then
	# Determine what subtask to replace.
	task_sub=$(echo "$task_show" | grep -w -F "$repo=$tag" ||:)
	subtask=${task_sub%%:*}
	subtask=${subtask##[[:space:]]}
	if [ -n "$subtask" ]; then
		# Determine next task to add before that.
		task_sub=$(echo "$task_show" | grep -A1 "^ $subtask:" | tail -n+2)
		nexttask=${task_sub%%:*}
		nexttask=${nexttask##[[:space:]]}
	fi
	unset task_sub
fi
unset task_show

task_run() {
	local task_id=$1
	if [ $sub_count -lt 1 ]; then
		echo >&2 "${RED}$sub_count subtasks, something went wrong.${NORM}"
		exit 1
	fi
	if [ $commit = --commit ] && [ $sub_count -ne 1 ]; then
		echo >&2 "${RED}Too many subtasks [$sub_count] for commit (unsafe).${NORM}"
		exit 1
	fi
	[ -z "$norun" ] || return
	V ssh -n "$girar" task run $dryrun $commit $failwhen $hurry "$task_id"
}

if [ -n "$subtask" ]; then
	# Verify tag_id
	subtext=$(ssh -n "$girar" task show "$task_id" | grep -P "^\s*$subtask:") \
		|| fatal "Subtask $subtask not found in task $task_id."
	task_tag_id=$(echo "$subtext" | grep -Po '^\s*\d+:tag_id=\K.*') \
		|| fatal "tag_id not found in subtask $subtask of $task_id."

	if [ "$tag_id" = "$task_tag_id" ]; then
		echo >&2 "${BLUE}tag_id for subtask is the same as ours, no need to re-add.${NORM}"
		echo >&2
		echo "$subtext" | sed 's/^/   /' >&2
		echo >&2
		[ $commit = --commit ] && task_run "$task_id"
		exit
	else
		echo >&2 "- Subtask $subtask tag_id=$task_tag_id obsolete, needs re-add."
		{ echo "$subtext"; echo; } >> .git/subtask.log
	fi

	echo >&2 "- Replacing subtask: $subtask"
	V ssh -n "$girar" task delsub "$task_id" "$subtask"
	sub_count+=-1
fi

# shellcheck disable=SC2086
V ssh -n "$girar" task add "$task_id" $nexttask "$dir_repo=$tag"
sub_count+=1

if [ -n "$disapprove" ]; then
	subtask=$(ssh -n "$girar" task show --brief "$task_id" | grep -F ":$repo=$tag" | grep -Po '^\s\K\d+')
	echo "$disapprove" | V ssh girar task disapprove "$task_id" "$subtask"
fi

task_run "$task_id"

if [ -n "$taillogs" ]; then
	task-tail "$taillogs" "$task_id" "$task_try"
fi
