#!/bin/bash
# shellcheck disable=SC2207,SC2128,SC2001,SC2046,SC2029,SC2059

set -efu -o pipefail
export LANG=C LC_ALL=C

   RED=$'\e[1;31m'
 GREEN=$'\e[1;32m'
  BLUE=$'\e[1;34m'
  NORM=$'\e[m'

V() {
        printf >&2 "${GREEN}+"
        printf >&2 ' %q' "$@"
        printf >&2 "${NORM}\n"
        "$@"
}

fatal() {
	printf >&2 "${RED}Error: %s${NORM}\n" "$*"
	exit 1
}

force=
commit=--test-only
dry=
newtask=
e2k=
girar=
gitery=
branch=
disapprove=
while [ $# -gt 0 ]; do
	opt=$1
	case "$opt" in
		-f | --force) force=-f ;;
		--commit) commit=--commit ;;
		-n | --dry | --dry-run) dry=y ;;
		--new | --new-task ) newtask=y ;;
		--e2k ) e2k=y ;;
		--repo=*) branch=${opt#*=} ;;
		--dis*) disapprove=y ;;
		*) fatal "Unknown option: $opt" ;;
	esac
	shift
done
toplevel=$(git rev-parse --show-toplevel)
cd "$toplevel"

# Determine gitery remote
if [ -n "$e2k" ]; then
	girar=girar-e2k
	gitery=gitery-e2k
else
	girar=girar
	gitery=gitery
	if [ -e .git/refs/remotes/git.alt ]; then
		V git remote rename "git.alt" "$gitery"
	fi
fi
if ! git config "remote.$gitery.url" >& /dev/null; then
	topname=$(basename "$toplevel")
	V ssh -n "$gitery" init-db "$topname"
	V git remote add "$gitery" "$gitery:packages/${topname}.git"
fi

tag=( $(git tag --points-at @ '*-alt*') )
if [ ${#tag[@]} -gt 1 ]; then
	fatal "Too many -alt tags: ${tag[*]}."
elif [ ${#tag[@]} -ne 1 ]; then
	fatal "Top level -alt tag is not found."
fi
tag_id=$(git show-ref --tags "$tag" | cut -d' ' -f1)
[ -n "$tag_id" ] || fatal "tag_id empty."

V git push "$gitery" "$tag" $force

# Remote repo name
url=$(git remote get-url "$gitery")
repo=$(basename "$url")

if [ -z "$newtask" ]; then
	# Are there already task for this?
	tasks_ls=$(ssh -n "$girar" task ls)
	task_exact=$(echo "$tasks_ls" | grep -m1 -w -F "$repo=$tag" || :)
else
	task_exact=
fi
if [ -n "$task_exact" ]; then
	if [ "$(echo "$task_exact" | wc -l)" -ne 1 ]; then
		echo >&2 "${RED}Too much tasks with $repo=$tag found:${NORM}"
		echo >&2
		echo "$task_exact" | sed 's/^/   /' >&2
		echo >&2
		exit 1
	fi
	task_id=${task_exact%% *}
	task_id=${task_id#\#}
	echo >&2 "- Task to rebuild $repo=$tag found: $task_id"

	task_state=$(echo "$task_exact" | cut -d' ' -f2)
	case "$task_state" in
		FAILED | NEW | TESTED | EPERM) ;;
		*) fatal "Task $task_id is in unmodifable state $task_state."
	esac

	# Determine what subtask to replace.
	task_show=$(ssh -n "$girar" task show --brief "$task_id")
	task_sub=$(echo "$task_show" | grep -w -F "$repo=$tag")
	if [ -z "$task_sub" ]; then
		echo >&2 "${RED}Cannot find subtask with ($repo=$tag) in task $task_id.${NORM}"
		echo >&2
		echo "$task_show" | sed 's/^/   /' >&2
		echo >&2
		exit 1
	elif [ $(echo "$task_sub" | wc -l) -ne 1 ]; then
		echo >&2 "${RED}Too much matching sub-tasks (with $repo=$tag) found:${NORM}"
		echo >&2
		echo "$task_show" | sed 's/^/   /' >&2
		echo >&2
		exit 1
	fi
	subtask=${task_sub%%:*}
	subtask=${subtask##[[:space:]]}

	# Verify tag_id
	subtext=$(ssh -n "$girar" task show "$task_id" | grep -P "^\s*$subtask:") \
		|| fatal "Subtask $subtask not found in task $task_id."
	task_tag_id=$(echo "$subtext" | grep -Po '^\s*\d+:tag_id=\K.*') \
		|| fatal "tag_id not found in subtask $subtask of $task_id."

	if [ "$tag_id" = "$task_tag_id" ]; then
		echo >&2 "${RED}tag_id for subtask is the same as ours, no need to re-add.${NORM}"
		echo >&2
		echo "$subtext" | sed 's/^/   /' >&2
		echo >&2
		exit 0
	else
		echo >&2 "- Subtask $subtask tag_id=$task_tag_id obsolete, needs re-add."
		{ echo "$subtext"; echo; } >> .git/subtask.log
	fi

	echo >&2 "- Replacing subtask: $task_sub"
	V ssh -n "$girar" task delsub "$task_id" "$subtask"
else
	task_repic=$(echo "$tasks_ls" | grep -m1 -w -F "$repo=" || :)
	if [ -n "$task_repic" ]; then
		echo >&2 "${BLUE}JFYI: There is other task(s) for $repo:${NORM}"
		echo >&2
		echo "$task_repic" | sed 's/^/   /' >&2
		echo >&2
	fi
	echo >&2 "- Task for rebuild not found, create new task."
	task_id=$(V ssh -n "$girar" task new $branch)
fi
V ssh -n "$girar" task add "$task_id" "$repo=$tag"

if [ -n "$disapprove" ]; then
	subtask=$(ssh -n "$girar" task show --brief "$task_id" | grep -F ":$repo=$tag" | grep -Po '^\s\K\d+')
	echo COMMIT BARRIER | V ssh girar task disapprove "$task_id" "$subtask"
fi

[ -n "$dry" ] || V ssh -n "$girar" task run $commit "$task_id"

