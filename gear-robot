#!/bin/bash
#
# Easy-peasy single command robot-bobot package update script
#
# Copyright (c) 2022-2023 Vitaly Chikunov <vt@altlinux.org>
# SPDX-License-Identifier: GPL-2.0-only
#
# shellcheck disable=SC2128,SC2207

# shellcheck source=/usr/bin/gear-utils-sh-functions
. gear-utils-sh-functions

set -euo pipefail
shopt -s extglob

V() {
        printf >&2 '\e[1;32m+'
        printf >&2 ' %q' "$@"
        printf >&2 '\e[m\n'
        "$@"
}

fatal() {
	printf >&2 "\e[1;31mError: %s\e[m\n" "$*"
	exit 1
}

warn() {
	printf >&2 "\e[1;34mWarning: %s\e[m\n" "$*"
}

info() {
	printf >&2 "\e[1;36minfo: %s\e[m\n" "$*"
}

force='' build='' push='' commit='' theirs=''
gears_update=y
keyserver="--auto-key-locate wkd"
unset nosignature keyurl readtreemerge disapprove allow_rc no_fetch
while [ $# -gt 0 ]; do
	opt=$1
	case "$opt" in
		-f | --force) force=-f ;;
		--build) build=y ;;
		--push)  build=y; push=y ;;
		--commit | --test-only) build=y; push=y; commit=$opt ;;
		--theirs ) theirs='-X theirs' ;;
		--no-gears ) unset gears_update ;;
		--all) build=y push=y commit=--commit ;;
		--keyserver=ubuntu) keyserver="--keyserver hkps://keyserver.ubuntu.com" ;;
		--keyserver) shift; keyserver="--keyserver $1" ;;
		--key=*) keyurl=${opt#*=} ;;
		--nosig* | --no-sig*) nosignature=y ;;
		--read-tree) readtreemerge=y ;;
		--disa*) disapprove=y ;;
		--rc) allow_rc=y ;;
		--no-vendor) no_vendor=y ;;
		--no-fetch) no_fetch=y ;;
		*) fatal "Unknown option: $opt" ;;
	esac
	shift
done

# Update repos
if [ -v gears_update ]; then
	# Add, update, and rebase over gears repo.
	V git gears-add
	# Show extra commits we have, should be none in normal circumstances.
	git l "gears/${branch-sisyphus}.."
fi

export disable_specsubst=1
chdir_to_toplevel
guess_specfile
# Sets '$specfile'.
export specfile

gear_describe() {
	# shellcheck disable=SC2046
	set -- $(gear --describe --disable-specsubst)
	export NAME=$1 VERSION=$2 RELEASE=$3
}
gear_describe

find_watchfile() {
	for WATCH in .gear/"$NAME"*.watch "$NAME"*.watch .gear/autobuild.watch .gear/*.watch *.watch ; do
		[ -e "$WATCH" ] && break
		WATCH=
	done
}

find_watchfile
# Prepare GPG
export GNUPGHOME=.gear/.gnupg
rm -rf "$GNUPGHOME"
(umask 077; mkdir -p "$GNUPGHOME")
# Basically we want keyserver set to
#   keyserver hkps://keys.openpgp.org
cp -a ~/.gnupg/gpg.conf $GNUPGHOME/
# Hide:
#   gpg: WARNING: This key is not certified with a trusted signature!
#   gpg:          There is no indication that the signature belongs to the owner.
echo "trust-model always" >> $GNUPGHOME/gpg.conf
if [ -v nosignature ]; then
	warn "Importing gpg keys skipped."
	# Call 'gpg' to initialize keyring, or else it will add to commit message:
	# "gpg: keybox '/home/vt/src/libkdumpfile/.gear/.gnupg/pubring.kbx' created"
	gpg2 --list-keys >/dev/null 2>&1
else
	if [ -e .gear/keys.gpg ] && [ ! -e .gear/upstream-signing-key.asc ]; then
		V git mv .gear/keys.gpg .gear/upstream-signing-key.asc
		V git commit -m "ALT: Rename GPG keys to be compatible with uscan"
	fi
	# Find upstream signing key.
	for GPGKEYS in {{.gear,.}/upstream-,debian/upstream/}signing-key.asc; do
		[ -e "$GPGKEYS" ] && break
		GPGKEYS=
	done
	if [ -e "$GPGKEYS" ]; then
		declare -p GNUPGHOME
		V gpg2 --quiet --import "$GPGKEYS"
	fi
fi

acquire_gpg_key() {
	local tag=$1
	if [ -e .gear/upstream-signing-key.asc ]; then
		echo >&2 "GPG key is known."
		return
	fi
	local object_type
	if [ -v keyurl ]; then
		curl -sSL "$keyurl" | V gpg2 --import |& tee .gear/GPG_IMPORT_OUTPUT
		gpg_command="Link: $keyurl"
	else
		object_type=$(git cat-file -t "$tag")
		# Extract required keyid from signature.
		git cat-file -p "$tag" | grep -e committer -e tagger
		echo "git verify-$object_type $tag" > .gear/GIT_VERIFY_OUTPUT
		git "verify-$object_type" "$tag" >> .gear/GIT_VERIFY_OUTPUT 2>&1 || :
		keyid=$(grep -Po "^gpg:\s+using \S+ key \K.*" .gear/GIT_VERIFY_OUTPUT)
		[ -n "$keyid" ] || fatal "No keyid to find."
		rm .gear/GIT_VERIFY_OUTPUT

		# --receive-keys cannot receive unapproved keys: https://keys.openpgp.org/about/faq#older-gnupg
		gpg_command="gpg2 $keyserver --receive-keys $keyid"
		# shellcheck disable=SC2086
		V $gpg_command |& tee .gear/GPG_IMPORT_OUTPUT
	fi

	# shellcheck disable=SC2155
	local who=$(grep -m1 -Po '^gpg: key \S+: public key "\K[^"]+(?=" imported)' .gear/GPG_IMPORT_OUTPUT)
	[ -n "$who" ] || fatal "Key is not imported."
	rm .gear/GPG_IMPORT_OUTPUT

	V gpg2 --list-keys
	V gpg2 --export --export-options export-minimal -a > .gear/upstream-signing-key.asc
	V git add -f .gear/upstream-signing-key.asc
	V git commit -m "ALT: Import GPG key for $who" -m "$gpg_command"
}

update_from_git_origin() {
	[ -v no_fetch ] ||
	V git fetch origin

	# Find latest (merged) upstream tag in this branch
	unset oldtag
	while read -r tag; do
		case "$tag" in
			@ | gb-*-task* | *-alt*) continue ;;
		esac
		oldtag=$tag
		echo "Latest merged tag is $oldtag"
		break
	done < <(git tag --sort=-creatordate --merged @)

	# Find new tags
	tags=()
	while read -r tag; do
		[ ! -v allow_rc ] && [[ $tag =~ -alt|^gb-|rc|beta|alpha ]] && continue
		# --is-ancestor: Check if the first <commit> is an ancestor of the second <commit>, and exit with status 0 if true.
		git merge-base --is-ancestor "$tag" HEAD && break
		# Consider only tags in this branch
		# [ -v oldtag ] && { git merge-base --is-ancestor "$oldtag" "$tag" || continue; }
		tags+=( "$tag" )
	done < <(git tag --sort=-creatordate -l)

	case ${#tags[@]} in
		0) warn "No new tags."; tag= ;;
		1) tag=$tags ;;
		*) tag=$(gum choose -- "${tags[@]}") ;;
	esac

	# Have tag to merge.
	if [ -n "$tag" ]; then
		echo "Selected tag: $tag"

		msg=".git/COMMIT_NEWMSG"
		printf "Merge tag '%s' into %s" "$tag" "$(git branch --show-current)" > "$msg"
		cleanup=
		if [ -v nosignature ]; then
			warn "Signature check skipped."
			tagstate=nosignature
		elif git cat-file -p "$tag" | grep -q 'BEGIN PGP SIGNATURE'; then
			acquire_gpg_key "$tag"
			# Hide:
			#   gpg: WARNING: Using untrusted key!
			echo "quiet" >> $GNUPGHOME/gpg.conf
			what=$(git cat-file -t "$tag")
			V git verify-$what "$tag"
			printf -- "Merge signed %s '%s' into %s\n\n%s" \
				"$what" \
				"$tag" \
				"$(git branch --show-current)" \
				"$(git verify-$what "$tag" |& sed 's/^/# /')" > "$msg"
			cleanup=--cleanup=whitespace
			tagstate=VERIFIED
		else
			warn "Lame upstream, tag is not signed."
			tagstate=unsigned
		fi

		# Actual merges.
		# shellcheck disable=SC2086
		if [ -v readtreemerge ]; then
			V git merge -s ours --no-commit "$tag"
			V git read-tree -u --reset "$tag"
			V git checkout @ -- .gear "$specfile"
			V git commit $cleanup --no-edit -F "$msg"
		elif ! V git merge --progress $cleanup $theirs --no-edit -F "$msg" "$tag"; then
			if [ -t 0 ]; then
				echo >&2
				echo ">>>>>>> This is merge failure shell." >&2
				# Try manual merge if user is here.
				GIT_PS1_SHOWCOLORHINTS=true \
				GIT_PS1_SHOWDIRTYSTATE=true \
				PS1='\w\[\033[1;35m\]$(__git_ps1)\[\033[m\]> ' \
				bash --rcfile <(cat ~/.bashrc; echo . /usr/share/git-core/contrib/completion/git-prompt.sh) || :
			fi
		fi

		# Check results.
		if git diff --quiet &&
		   git diff --quiet --cached &&
		   git merge-base --is-ancestor "$tag" HEAD; then
			info "Merge OK. Continuing..."
		else
			fatal "Merge failed!"
		fi

		if [ -v readtreemerge ]; then
			V git commit --no-edit --amend --trailer "Merge-Strategy: read-tree"
		elif [ -n "$theirs" ]; then
			V git commit --no-edit --amend --trailer "Merge-Strategy: theirs"
		fi
	else
		tagstate=unknown
	fi
}

# Update upstream code.
if [ -n "$WATCH" ]; then
	# rpm-uscan will download and verify signature (based on .watch file)
	# but will not record result of verification anywhere (except stdout),
	# so we will need to verify it again.
	printf '$ rpm-uscan --watchfile=%q\n' "$WATCH" > .gear/IMPORT_OUTPUT
	set +e
	V rpm-uscan --watchfile="$WATCH"
	RET=$?
	set -e
	query=$(uscan-query -a "$WATCH" 2>/dev/null | sed 's/[[:space:]]/_/g' || :)
	# shellcheck disable=SC2086
	[ -n "$query" ] && declare $query
	[ -v STATUS ] || STATUS="uscan-query error"
	if [ "$RET" -eq 0 ]; then
		warn "Status: ${STATUS//_/ }"
	else
		fatal "Nothing to update (${STATUS//_/ })"
	fi

	printf '$ sha256sum %q\n' "$FILENAME" >> .gear/IMPORT_OUTPUT
	V sha256sum "$FILENAME" | tee -a .gear/IMPORT_OUTPUT

	if [ -e "$FILENAME.asc" ]; then
		echo "quiet" >> $GNUPGHOME/gpg.conf
		echo "$ gpg2 --verify $FILENAME.asc" >> .gear/IMPORT_OUTPUT
		V gpg2 --verify "$FILENAME.asc"
		gpg2 --verify "$FILENAME.asc" >> .gear/IMPORT_OUTPUT 2>&1
		tagstate=VERIFIED
	else
		tagstate=unsigned
	fi
	printf '$ gear-import --no-tag %q\n' "$FILENAME" >> .gear/IMPORT_OUTPUT
	gear-import --no-tag "$FILENAME"
	{
		# Amend to append import relevant info.
		git log --format=%B -n1
		cat .gear/IMPORT_OUTPUT
		printf '\nLink: %s\n' "$URL"
		curl -s -I "$URL" | grep -i -e ^last-modified: -e ^etag:
	} | V git commit -q --amend -F-
else
	update_from_git_origin
	git rev-parse @^2 >/dev/null 2>&1 || fatal "Not in a merge commit."
fi

git cat-file -p @ | grep -q '^committer .*@altlinux.org>' || fatal "Foreign merge commit."

# Continue after we have merged upstream sources.
if [ -n "$WATCH" ]; then
	log=$(git log --format=%s -n1)
	case "$log" in
		Import?archive?*-*) ver=${log##*-} ;;
		*) fatal "No import message in top commit: '$log'."
	esac
	info "Top commit version $ver ($tagstate)."
	unset tag
else
	# What tag is merged?
	tags=( $(git tag --points-at @^2) )
	case ${#tags[@]} in
		0) fatal "No tags at HEAD." ;;
		1) tag=$tags ;;
		*) warn "Too many tags pointing at HEAD: ${tags[*]}" ;;
	esac
	# Delete letter prefixes with a dash. Then delete version prefix 'v'.
	ver=${tag##+([[:alpha:]])-}
	ver=${ver#*[Vv]}
	[ -z "${ver##*-*}" ] && ver="${ver//-/.}"
	info "Top tag is $tag ($tagstate), Version: $ver"
fi
if [[ ! "$ver" =~ ^[[:digit:]]+(.[[:digit:]]+)*$ ]]; then
	[ -v allow_rc ] && disapprove=y || fatal "Unknown version format: $ver"
fi

futag=$ver-alt1
[ -z "$force" ] && [ -n "$(git tag -l "$futag")" ] \
	&& fatal "Future tag $futag already exists (--force to skip this check)."

# Make sure we have newer version than that in repo.
if [ -d /ALT/ ]; then
	repo=${branch-Sisyphus}
	srpm=( $(ls "/ALT/$repo/files/SRPMS/$NAME"-+([^-])-+([^-])".src.rpm") )
	suff=${srpm%-*-*.src.rpm}
	revr=${srpm#"$suff-"}
	revr=${revr%.src.rpm}

	case $(rpmevrcmp "$futag" "$revr") in
		-1) fatal "Package version in $repo $revr is newer than $futag";;
		0)  fatal "Package version in $repo $revr is equal to $futag" ;;
		1)  info  "Package version in $repo $revr is older than $futag" ;;
		*)  fatal "'rpmevrcmp $futag $revr' error."
	esac
	unset suff repo
else
	fatal "Package versions cannot be compared (cuz no /ALT/)."
fi

# Vendorize.
cmd=
if [ -v no_vendor ]; then
	:
elif [ -f Cargo.toml ]; then
	if type -p cargo-vendor-filterer-no >/dev/null; then
		cmd="cargo vendor-filterer"
		rm -rf vendor
		V cargo vendor-filterer \
			--platform=x86_64-unknown-linux-gnu
	else
		cmd="cargo vendor"
		V cargo vendor --quiet
		# Delete garbage.
		V find vendor/ \( -name '*.a' -o -name '*.lib' -o -name '*.dll' -o -name '*.obj' \) -delete
		# No verbose output cuz too much .cargo-checksum.json-s
		# shellcheck disable=SC2046
		sed -Ei 's!,"[^"]+\.(a|lib|dll|obj)":"[^"]+"!!g' $(find vendor -name .cargo-checksum.json)
	fi
	V git add -f Cargo.lock
elif [ -f go.mod ]; then
	cmd="go mod vendor"
	# shellcheck disable=SC2086
	V $cmd
fi
if [ -n "$cmd" ] && [ -d vendor ]; then
	grep -sq -w 'text' .gitattributes && echo '* -text' > vendor/.gitattributes
	V git add -f -A vendor
	if git diff --quiet --cached; then
		info "Vendoring is unchanged."
	else
		V git commit -q -m "ALT: $cmd"
	fi
fi

sver=$(grep -Po '^Version:\s*\K\S+' "$specfile")
[ -n "$sver" ] || fatal "No 'Version:' found in $specfile"
# $sver is unquoted to detect parse errors.
# shellcheck disable=SC2086
case $(rpmvercmp "$ver" $sver) in
	-1) fatal "Version in $specfile is newer than $ver" ;;
	0)  fatal "Version in $specfile is equal to $ver" ;;
	1) ;;
	*)  fatal "'rpmvercmp $ver $sver' error." ;;
esac

# Modify spec.
if [ -v tag ]; then
	new_tag_date=$(git log -1 --pretty=format:%cd --date=format:%Y-%m-%d "$tag")
	append_changelog="- Update to $tag ($new_tag_date)."
else
	# gear-impor sets author date to archive mtime.
	new_ver_date=$(git log -1 --pretty=format:%ad --date=format:%Y-%m-%d)
	append_changelog="- Update to $ver ($new_ver_date)."
fi
sed -i -E "s/^Version:.*/Version: $ver/" "$specfile"
sed -i -E "s/^Release:.*/Release: alt1/" "$specfile"
safe-add-changelog -e "$append_changelog" "$specfile"

# Build nefore tagging.
[ -n "$build" ] && V gear-hsh --commit 2>&1 | tee build.log

# Tag.
git diff
V git add -f "$specfile"
V gear-commit --no-edit
git l --first-parent  -3
unset GNUPGHOME
setsid gear-create-tag $force

# Externalize changes.
[ -n "$push" ]  && V git push gitery "$futag" $force
if [ -n "$commit" ]; then
	# shellcheck disable=SC2086
	task=$(V ssh -n girar task new ${branch-})
	echo "$task" > .gear/task
	V ssh -n girar task add "$task" repo "$NAME" "$futag"
	if [ -v disapprove ]; then
		subtask=$(ssh -n girar task show --brief "$task" | grep -e ":$NAME\.git=" | grep -Po '^\s\K\d+')
		echo TEST | V ssh girar task disapprove "$task" "$subtask"
	fi
	V ssh -n girar task run "$commit" "$task"
fi

